# Computer design parameters
.const screenWidth,      $64
.const screenHeight,     $64

.const display,          $0x4000
.const displayEnd,       [display + screenWidth * screenHeight]
.const _dev,             $0x6000
.const devbutton,        [_dev + 0]
.const devframe,         [_dev + 1]
.const devmidi,          [_dev + 2]
.const highZaddress,     $0xFFFF


.const colorBlack,       $0
.const colorWhite,       $1
.const colorOrange,      $8
.const colorPink,        $9
#.const colorLightblue,   todo


# button masks
.const buttonLeftUp,     [1 << 7]  # up arrow
.const buttonLeftDown,   [1 << 6]  # down arrow
.const buttonRightUp,    [1 << 3]  # top face
.const buttonRightDown,  [1 << 0]  # bottom face


# Program parameters
.const paddleHeight,     $8
.const paddlePadding,    $8
.const paddleLeftX,      paddlePadding
.const colorBackground,  colorBlack
.const colorPaddleLeft,  colorOrange
.const colorPaddleRight, colorPink

.const paddleRightX,     [screenWidth - paddlePadding]
.const paddleMaxY,       [screenHeight - paddleHeight]


# Global variable addresses
.const paddleLeftY,      $0x10
.const paddleRightY,     $0x11
.const ballX,            $0x12
.const ballY,            $0x13
.const ballSpeedX,       $0x14
.const ballSpeedY,       $0x15
.const ballColor,        $0x16

.const scoreLeft,        $0x17
.const scoreRight,       $0x18

.const inputLeftDir,     $0x19
.const inputRightDir,    $0x20




# --------------------------------------
@init_stack

brk

@call resetBall, $0

brk

ldc %b, [(screenHeight - paddlePadding) / 2]
ldc %a, paddleLeftY
stb %a, %b
ldc %a, paddleRightY
stb %a, %b





mainLoop:
@call updateInputs, $0
@call updateGame,   $0
@call updateScreen, $0

@ldc %a, mainLoop
jump %a




# --------------------------------------
resetBall:
@function $0

ldc %a, ballColor
ldc %b, colorWhite
stb %a, %b

ldc %a, ballX
ldc %b, [screenWidth / 2]
stb %a, %b

ldc %a, ballY
ldc %b, [screenHeight / 2]
stb %a, %b

# use high-Z memory address to determine paddle direction.
# X speed = bit 0
# Y speed = bit 1
# 0 => speed = -1
# 1 => speed = 1
@ldc %a, highZaddress
ldb %a, %a


# (highZ & 0b01) * 2 - 1:
#   bit0(highZ) == 0 => -1
#   bit0(highZ) == 1 =>  1
ldc %b, $0b01
and %a, %a, %c

ldc %b, $2
mul %a, %a, %b

ldc %b, $1
sub %a, %a, %b

ldc %b, ballSpeedX
stb %b, %a


# same for ballSpeedY (but use bit 1 instead of bit 0)
ldc %b, $0b10
and %a, %a, %c

ldc %b, $2
mul %a, %a, %b

ldc %b, $1
sub %a, %a, %b

ldc %b, ballSpeedY
stb %b, %a

@return




# --------------------------------------
# args: none
updateInputs:
@function $0

# TODO we are using buttons to move the paddles up and down. What do you think of using a rotary encoder to determine its position? Like one of those truly old pong machines. It might even be simpler to code.

# TODO read button device and set inputLeftDir and inputRightDir.
# -1 => paddle moving UP (Y--)
#  0 => paddle staying still
#  1 => paddle moving DOWN (Y++)

ldc %b, $0
ldc %a, inputLeftDir
stb %a, %b
ldc %a, inputRightDir
stb %a, %b

# Highly simplified alternative to properly reading the buttons.
@ldc %a, devbutton
ldb %a, %a

ldc %d, updateInputs_return

ldc %b, buttonLeftUp
ldc %c, updateInputs_leftUp
jeq %b, %a, %c

ldc %b, buttonLeftDown
ldc %c, updateInputs_leftDown
jeq %b, %a, %c

ldc %b, buttonRightUp
ldc %c, updateInputs_rightUp
jeq %b, %a, %c

ldc %b, buttonRightDown
ldc %c, updateInputs_rightDown
jeq %b, %a, %c

ldc %a, updateInputs_return
jmp %a


updateInputs_leftUp:
ldc %a, inputLeftDir
@ldc %b, [0 - 1]
stb %a, %b
jmp %d

updateInputs_leftDown:
ldc %a, inputLeftDir
@ldc %b, $1
stb %a, %b
jmp %d

updateInputs_rightUp:
ldc %a, inputRightDir
@ldc %b, [0 - 1]
stb %a, %b
jmp %d

updateInputs_rightDown:
ldc %a, inputRightDir
@ldc %b, $1
stb %a, %b
jmp %d


updateInputs_return:
@return




# --------------------------------------
# args: none
updateGame:
@function $0

# Move paddles according to inputLeftDir and inputRightDir
@push_mem paddleLeftY
@push_mem inputLeftDir
@add
@pop_mem_v paddleLeftY

@push_mem paddleRightY
@push_mem inputRightDir
@add
@pop_mem_v paddleRightY


# TODO: move ball according to ballSpeedX and ballSpeedY

# TODO: collide ball with paddles. On collision, invert X speed and set ballColor to the color of the paddle it hit.
# TODO: collide ball with top/bottom walls. Invert Y speed.
# TODO: collide ball with left/right walls. Call resetBall, and increment score.


# WISHLIST FEATURE: need a clock device that we can use the move objects at a consistent speed.
# It doesn't necessarily have to count seconds "outside the simulator", but it at least needs to count clock ticks independently of the CPU.
# But until this is implemented, we can get away with tying the object speed to the clock speed, as the program's main loop *should* run in constant time, so we can just set the clock speed to directly determine the object speed.

@return




# --------------------------------------
# TODO test
# args: none
updateScreen:
@function $0

@call clearScreen, $0

@push_const paddleLeftX
@push_mem_a paddleLeftY
@push_const colorPaddleLeft
@call drawPaddle, $3

@push_const paddleRightX
@push_mem_a paddleRightY
@push_const colorPaddleRight
@call drawPaddle, $3

@push_mem_a ballX
@push_mem_a ballY
@push_mem ballColor
@call drawBall, $3


# TODO draw score
# TODO draw midline


@return




# --------------------------------------
# TODO test
clearScreen:
@function $0

# %a = display
# do {
#   *a = colorBackground;
#   %a = %a + 1;
# } while (%a <= displayEnd);

@ldc %a, display
@ldc %b, displayEnd
ldc %c, colorBackground
# %d will be used for both $1 and the jump label

clearScreen_loop1:

stb %a, %c

ldc %d, $1
add %a, %a, %d

ldc %d, clearScreen_loop1
jle %d, %a, %b

@return




# --------------------------------------
# TODO test
# args: X coordinate, Y coordinate of paddle top, color
drawPaddle:
@function $0

@push_arg $0
@push_arg $1
@push_const paddleHeight
@push_const $2

@return




# --------------------------------------
# TODO test
# args: X coordinate, Y coordinate of top, length in pixels, color
drawVerticalLine:
@function $2

# pixel* position = display + y * screenWidth + x
@push_arg $0
@push_const display
@push_arg $1
@push_const screenWidth
@mul
@add
@pop_local $0

# endPosition = position + length * screenWidth
@push_local $0
@push_arg $2
@push_const screenWidth
@mul
@add
@pop_local $1

# do {
#   *position = color;
#   position = position + screenWidth;
# } while (position < endPosition);

# position    = local 0
# endPosition = local 1
# color       = arg 2
# screenWidth = constant

drawVerticalLine_loop1:
@push_arg $2
@push_local $0
@pop_mem_av

@push_local $0
@push_const screenWidth
@add
@pop_local $0

@push_local $0
@push_local $1

@pop_reg %d # %d = endPosition
@pop_reg %c # %c = position
ldc %b, drawVerticalLine_loop1
jlt %b, %c, %d

@return




# --------------------------------------
# TODO test
# args: X coordinate, Y coordinate, color
drawBall:
@function $0

# %a = display + screenWidth * Y + X
@push_arg $0
@push_const display
@push_const screenWidth
@push_arg $1
@mul
@add
@add

@push_arg $2

@pop_mem_av

@return
