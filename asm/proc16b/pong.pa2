# Computer design parameters
.const screenWidth,      $64
.const screenHeight,     $64

.const display,          $0x4000
.const displaySize,      [screenWidth * screenHeight]
.const displayEnd,       [display + displaySize]
.const _dev,             $0x6000
.const devbutton,        [_dev + 0]
.const devframe,         [_dev + 1]
.const devmidi,          [_dev + 2]
.const highZaddress,     $0xFFFF


.const colorBlack,       $1
.const colorWhite,       $0
.const colorOrange,      $8
.const colorPink,        $9
#.const colorLightblue,   todo


# button masks
.const buttonLeftUp,     [1 << 7]  # up arrow
.const buttonLeftDown,   [1 << 6]  # down arrow
.const buttonRightUp,    [1 << 3]  # top face
.const buttonRightDown,  [1 << 0]  # bottom face


# Program parameters
.const paddleHeight,     $8
.const paddlePadding,    $8
.const colorBackground,  colorBlack
.const colorPaddleLeft,  colorOrange
.const colorPaddleRight, colorPink


.const paddleLeftX,      paddlePadding
.const paddleRightX,     [screenWidth - paddlePadding]
.const paddleMaxY,       [screenHeight - paddleHeight]


# Global variable addresses
.const paddleLeftY,      $0x10
.const paddleRightY,     $0x11
.const ballX,            $0x12
.const ballY,            $0x13
.const ballSpeedX,       $0x14
.const ballSpeedY,       $0x15
.const ballColor,        $0x16

.const scoreLeft,        $0x17
.const scoreRight,       $0x18

.const inputLeftDir,     $0x19
.const inputRightDir,    $0x1A




# --------------------------------------
@init_stack

@call resetBall, $0

ldc %b, [(screenHeight - paddlePadding) / 2]
ldc %a, paddleLeftY
stb %a, %b
ldc %a, paddleRightY
stb %a, %b




mainLoop:
@call updateInputs, $0
@call updateGame,   $0
@call updateScreen, $0

@ldc %a, mainLoop
jump %a




# --------------------------------------
resetBall:
@function $0

ldc %a, ballColor
ldc %b, colorWhite
stb %a, %b

ldc %a, ballX
ldc %b, [screenWidth / 2]
stb %a, %b

ldc %a, ballY
ldc %b, [screenHeight - 10] #[screenHeight / 2] TODO temporary dev thing
stb %a, %b

# use high-Z memory address to determine paddle direction.
# TODO use proper RNG device
# X speed = bit 0
# Y speed = bit 1
# 0 => speed = -1
# 1 => speed = 1
@ldc %c, highZaddress
ldb %c, %c


# (highZ & 0b01) * 2 - 1:
#   bit0(highZ) == 0 => -1
#   bit0(highZ) == 1 =>  1
ldc %d, $1
ldc %b, $0b01
and %a, %c, %b

ldc %b, $2
mul %a, %a, %b

sub %a, %a, %d

ldc %b, ballSpeedX
stb %b, %a


# same for ballSpeedY (but use bit 1 instead of bit 0 - so need to shr it as well)
ldc %b, $0b10
and %a, %c, %b
shr %a, %a, %d

ldc %b, $2
mul %a, %a, %b

sub %a, %a, %d

@ldc %a, $1 # TODO temporary dev thing
ldc %b, ballSpeedY
stb %b, %a

@return




# --------------------------------------
# read button device and set inputLeftDir and inputRightDir.
# -1 => paddle moving UP (Y--)
#  0 => paddle staying still
#  1 => paddle moving DOWN (Y++)
# args: none
updateInputs:
@function $0

# TODO we are using buttons to move the paddles up and down. What do you think of using a rotary encoder to determine its position? Like one of those truly old pong machines. It might even be simpler to code.


# *inputLeftDir = readButton(state, buttonLeftDown) - readButton(state, buttonLeftUp)
# so that pushing down makes it 1, pushing up makes it -1, and pushing both or none makes it 0.
@push_const buttonLeftDown
@call_value readButton, $1

@push_const buttonLeftUp
@call_value readButton, $1

@sub
@pop_mem_v inputLeftDir

# same but for right
@push_const buttonRightDown
@call_value readButton, $1

@push_const buttonRightUp
@call_value readButton, $1

@sub
@pop_mem_v inputRightDir


@return




# --------------------------------------
# args: mask
# returns: 0x0 or 0x1
readButton:
@function $0

# return ((state & mask) > 0) & 1
# where something > something returns 0x0000 or 0xFFFF

@push_mem devbutton
@push_arg $0
@and
@push_const $0
@gt
@push_const $1
@and

@return_value




# --------------------------------------
# args: none
updateGame:
@function $0

# Move paddles according to inputLeftDir and inputRightDir
@push_mem paddleLeftY
@push_mem inputLeftDir
@add
@pop_mem_v paddleLeftY

@push_mem paddleRightY
@push_mem inputRightDir
@add
@pop_mem_v paddleRightY


# move ball according to ballSpeedX and ballSpeedY
@push_mem ballX
@push_mem ballSpeedX
@add
@pop_mem_v ballX

@push_mem ballY
@push_mem ballSpeedY
@add
@pop_mem_v ballY


# TODO: collide ball with paddles. On collision, invert X speed and set ballColor to the color of the paddle it hit.

# if ballX == paddleLeftX && ballY >= paddleLeftY && ballY <= (paddleLeftY + paddleHeight):
#   ballX = paddleLeftX + 1
#   ballSpeedX = 0 - ballSpeedX

@push_mem ballX
@push_const paddleLeftX
@eq

@push_mem ballY
@push_mem paddleLeftY
@gte

@push_mem ballY
@push_mem paddleLeftY
@push_const paddleHeight
@add
@lte

@and
@and
@if updateGame_flipBallX1

    @push_const [paddleLeftX + 1]
    @pop_mem_v ballX
    
    @push_const $0
    @push_mem ballSpeedX
    @sub
    @pop_mem_v ballSpeedX
    
    @push_const colorPaddleLeft
    @pop_mem_v ballColor

updateGame_flipBallX1:

# TODO same for right



# collide ball with top/bottom walls. Invert Y speed.
# if ballY <= 0:
#   ballY = 0
#   ballSpeedY = 0 - ballSpeedY
@push_mem ballY
@push_const $0
@lte
@if updateGame_flipBallY1

    @push_const $0
    @pop_mem_v ballY

    @push_const $0
    @push_mem ballSpeedY
    @sub
    @pop_mem_v ballSpeedY

updateGame_flipBallY1:

# if ballY >= screenHeight:
#   ballY = screenHeight - 1
#   ballSpeedY = 0 - ballSpeedY
@push_mem ballY
@push_const screenHeight
@gte
@if updateGame_flipBallY2

    @push_const [screenHeight - 2]
    @pop_mem_v ballY

    @push_const $0
    @push_mem ballSpeedY
    @sub
    @pop_mem_v ballSpeedY

updateGame_flipBallY2:


# TODO: collide ball with left/right walls. Call resetBall, and increment score.


# WISHLIST FEATURE: need a clock device that we can use the move objects at a consistent speed.
# It doesn't necessarily have to count seconds "outside the simulator", but it at least needs to count clock ticks independently of the CPU.
# But until this is implemented, we can get away with tying the object speed to the clock speed, as the program's main loop *should* run in constant time, so we can just set the clock speed to directly determine the object speed.

@return




# --------------------------------------
# args: none
updateScreen:
@function $0

@call clearScreen, $0

@push_mem ballX
@push_mem ballY
#@push_mem ballColor
@push_const colorWhite
@call drawBall, $3

@push_const paddleRightX
@push_mem   paddleRightY
@push_const colorPaddleRight
@call drawPaddle, $3

@push_const paddleLeftX
@push_mem   paddleLeftY
@push_const colorPaddleLeft
@call drawPaddle, $3


# TODO draw score
# TODO draw midline


# Flip frame buffer
@ldc %a, devframe
ldb %a, %b
not %b, %b

ldc %c, $1
and %b, %b, %c
stb %a, %b


@return




# --------------------------------------
clearScreen:
@function $0

# %c = &frameBuffer
# displayEnd = %c + displaySize
# do {
#   *c = colorBackground;
#   %c = %a + 1;
# } while (%c <= displayEnd);

@call_value getFrameBuffer, $0
@pop_reg %c

# %b = displayEnd = %c + displaySize
@ldc %b, displaySize
add %d, %c, %b


ldc %a, colorBackground
# %b will be used for both $1 and the jump label

clearScreen_loop1:

stb %c, %a

ldc %b, $1
add %c, %c, %b

ldc %b, clearScreen_loop1
jle %b, %c, %d

@return




# --------------------------------------
# args: X coordinate, Y coordinate of paddle top, color
drawPaddle:
@function $0

@push_arg $0
@push_arg $1
@push_const paddleHeight
@push_arg $2
@call drawVerticalLine, $4

@return




# --------------------------------------
# args: X coordinate, Y coordinate of top, length in pixels, color
drawVerticalLine:
@function $2

# pixel* position = &frameBuffer + y * screenWidth + x
@call_value getFrameBuffer, $0

@push_arg $1
@push_const screenWidth
@mul
@add
@push_arg $0
@add
@pop_local $0

# endPosition = position + length * screenWidth
@push_local $0
@push_arg $2
@push_const screenWidth
@mul
@add
@pop_local $1

# do {
#   *position = color;
#   position = position + screenWidth;
# } while (position < endPosition);

# position    = local 0
# endPosition = local 1
# color       = arg 2
# screenWidth = constant

drawVerticalLine_loop1:
@push_arg $3
@push_local $0
@pop_mem_av

@push_local $0
@push_const screenWidth
@add
@pop_local $0

@push_local $0
@push_local $1

@pop_reg %d # %d = endPosition
@pop_reg %c # %c = position
@ldc %b, drawVerticalLine_loop1
jlt %b, %c, %d

@return




# --------------------------------------
# args: X coordinate, Y coordinate, color
drawBall:
@function $0

# pixel = &frameBuffer + screenWidth * Y + X
@call_value getFrameBuffer, $0
@push_const screenWidth
@push_arg $1
@mul
@add
@push_arg $0
@add

# *pixel = color
@push_arg $2
@pop_mem_va

@return




# --------------------------------------
# args: none
# returns: current framebuffer pointer
getFrameBuffer:
@function $0

@push_const display
@push_const devframe
@push_mem_a
@not
@push_const $1
@and
@push_const displaySize
@mul
@add

@return_value
